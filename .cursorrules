# MathSageAI - Cursor Rules

## Memory Bank System

I am Cursor, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.

### Memory Bank Structure

The Memory Bank consists of required core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

**Core Files (Required):**
1. `memory-bank/projectbrief.md` - Foundation document that shapes all other files
2. `memory-bank/productContext.md` - Why this project exists, problems it solves
3. `memory-bank/activeContext.md` - Current work focus, recent changes, next steps
4. `memory-bank/systemPatterns.md` - System architecture, key technical decisions
5. `memory-bank/techContext.md` - Technologies used, development setup, dependencies
6. `memory-bank/progress.md` - What works, what's left to build, current status

### Usage Instructions
- **Read ALL memory bank files at the start of EVERY task** - This is mandatory
- Update memory bank when discovering new patterns or implementing changes
- Use "update memory bank" trigger to refresh context
- Maintain precision and clarity - effectiveness depends on accuracy

### Memory Bank Location
All memory bank files are located in the `memory-bank/` directory at the project root.

## Decision Making Protocol

When making architectural or technical decisions, ALWAYS:
1. Review DECISION_MAKING.md for alternatives, pros/cons
2. Discuss trade-offs with the team/user before implementing
3. Consider MVP vs production needs
4. Document the decision and rationale

## Core Principles

- **MVP First**: Choose simplest option that works for the current milestone
- **Iterate Later**: Can always refactor/upgrade, don't over-engineer
- **Document Decisions**: Explain why, not just what
- **Team Familiarity**: Leverage existing knowledge when possible
- **Cost-Aware**: Consider API costs, hosting costs, maintenance burden

## Documentation Rules

- **NO CODE IN DOCUMENTS**: All documentation files (.md) must be conceptual only
  - No code blocks, code examples, or code snippets
  - Use descriptive text, bullet points, and conceptual explanations
  - Architecture diagrams should be text-based (not code blocks)
  - File structures should be listed (not code blocks)
  - API examples should describe structure conceptually (not JSON/code)
  - Keep documents easy to review and understand without code
  - Focus on: what, why, pros/cons, decisions, not how (implementation)

- **NO DOCUMENTS FOR SIMPLE QUESTIONS**: Answer simple questions directly in chat, don't create documents
  - Simple questions: explanations, comparisons, recommendations, quick answers
  - Only create documents for: complex plans, architectural decisions, comprehensive guides, project planning
  - When in doubt: answer in chat first, create document only if user explicitly requests it
  - Documents should be substantial and reference-worthy, not quick answers

## Tech Stack Decisions (Current)

### Frontend
- **Framework**: Next.js (React) with TypeScript
- **UI**: Tailwind CSS + shadcn/ui components
- **Math Rendering**: KaTeX (fast, lightweight)
- **State**: React Context API (MVP) → Zustand if needed
- **Image Upload**: React Dropzone with base64 encoding

### Backend
- **Platform**: Next.js API Routes on Amplify (MVP) → AWS Lambda + API Gateway (production)
- **LLM**: OpenAI (GPT-4 Vision for images, GPT-4 for dialogue)
- **Session Storage**: AWS DynamoDB (MVP) → AWS ElastiCache Redis (production)
- **Image Processing**: OpenAI Vision API (best quality)
- **Image Storage**: AWS S3
- **Secrets Management**: AWS Secrets Manager

### Deployment
- **Frontend**: AWS Amplify (MVP) → S3 + CloudFront (production)
- **Backend**: Next.js API Routes on Amplify (MVP) → AWS Lambda + API Gateway (production)
- **Storage**: AWS DynamoDB (sessions) + S3 (images)
- **Secrets**: AWS Secrets Manager (API keys)

## Decision Points - Always Discuss First

Before implementing any of these, discuss alternatives:

1. **Adding new dependencies** - Check if existing solution works
2. **Changing storage approach** - Consider MVP vs production needs
3. **Adding new services** - Evaluate cost vs benefit
4. **Architecture changes** - Review impact on simplicity
5. **New LLM integrations** - Consider cost, quality, alternatives
6. **UI/UX changes** - Ensure they align with PRD goals

## Code Style & Patterns

- **TypeScript**: Use strict types, avoid `any`
- **Components**: Functional components with hooks
- **Error Handling**: Always handle errors gracefully
- **API Calls**: Use try/catch, provide user feedback
- **State**: Keep state as local as possible, lift only when needed

## Socratic Tutoring Rules

- **NEVER give direct answers** - Always guide through questions
- **Validate responses** - Check that AI doesn't give solutions
- **Escalate hints** - After 2+ turns, provide concrete hints
- **Encouraging tone** - Use positive, supportive language
- **Context maintenance** - Keep conversation history for continuity

## Testing Requirements

- Test with 5+ problem types (arithmetic, algebra, geometry, word problems, multi-step)
- Verify no direct answers are given
- Test image parsing with various formats
- Verify math rendering works correctly
- Test conversation context maintenance

## File Structure

**Project Structure:**
- frontend/ - Next.js app
- backend/ - API routes or separate service
- docs/ - Documentation
- ARCHITECTURE.md - System architecture
- DECISION_MAKING.md - Decision guide with alternatives
- .cursorrules - This file

## Before Making Changes

1. Check if decision is needed → Review DECISION_MAKING.md
2. If architectural change → Discuss with team/user first
3. If adding dependency → Consider alternatives and cost
4. If changing approach → Document why and trade-offs
5. If creating/editing documentation → NO CODE BLOCKS (conceptual only)

## Common Decisions Reference

- **Frontend Framework**: Next.js (discussed, chosen for simplicity)
- **Backend**: Next.js API Routes on Amplify (discussed, MVP choice)
- **Deployment**: AWS Amplify (MVP) → Lambda + API Gateway (production)
- **LLM**: OpenAI (discussed, best quality)
- **Storage**: AWS DynamoDB (discussed, MVP choice) → ElastiCache Redis (production)
- **Image Storage**: AWS S3 (discussed, cost-effective)
- **Math**: KaTeX (discussed, fast and lightweight)
- **Image Processing**: OpenAI Vision (discussed, best accuracy)
- **Secrets**: AWS Secrets Manager (discussed, secure)

## Anti-patterns to Avoid

- ❌ Adding complexity "just in case"
- ❌ Choosing tech because it's new/shy
- ❌ Over-engineering for problems we don't have
- ❌ Skipping documentation of decisions
- ❌ Making decisions without considering alternatives
- ❌ Ignoring cost implications

## When to Revisit Decisions

- API costs becoming too high
- Performance issues arise
- Scaling requirements change
- Better alternatives emerge
- Team expertise changes
- MVP milestones completed

## Quick Decision Checklist

Before implementing:
- [ ] Reviewed alternatives in DECISION_MAKING.md?
- [ ] Discussed with team/user?
- [ ] Considered MVP vs production?
- [ ] Evaluated cost implications?
- [ ] Documented rationale?
- [ ] Is it the simplest solution that works?

---

**Remember**: MVP first, iterate later. Discuss decisions, document rationale, keep it simple.

